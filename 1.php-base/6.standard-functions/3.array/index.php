<?php

declare(strict_types=1);

// включение вывод всех ошибок
error_reporting(E_ALL);
ini_set('display_errors', 'on');

// выключение вывод всех ошибок
// error_reporting(0);
// ini_set('display_errors', 'off');

// Кодировка
mb_internal_encoding('UTF-8');

// Работа с in_array
// Функция in_array проверяет наличие заданного элемента в массиве. Первым параметром она принимает что искать, а вторым - в каком массиве in_array(что искать, в каком массиве);

// Работа с array_sum и array_product
// Функция array_sum вычисляет сумму элементов массива array_sum(массив);
// Функция array_product вычисляет произведение (умножение) элементов массива array_product(массив);

// Работа с range
// Функция range создает массив с диапазоном элементов. К примеру, можно создать массив, заполненный числами от 1 до 100 или буквами от 'a' до 'z'. Диапазон, который сгенерирует функция, задается параметрами: первый параметр откуда генерировать, а второй - докуда.
// Третий необязательный параметр функции задает шаг. К примеру, можно сделать ряд 1, 3, 5, 7, если задать шаг 2, или ряд 1, 4, 7, 10 если задать шаг 3 range(откуда, докуда, [шаг]);

// Работа с array_merge
// Функция array_merge сливает два и более массива вместе. Если в сливаемых массивах встречаются одинаковые ключи - останется только один из таких элементов. Если вам нужно, чтобы остались все элементы с одинаковыми ключами - используйте функцию array_merge_recursive array_merge(первый массив, второй массив...);

// Работа с array_slice
// Функция array_slice отрезает и возвращает часть массива. При этом сам массив не меняется. Первым параметром указывается массив для разрезания. Вторым параметром указывается, с какого элемента начинать отрезание, а третьим - сколько элементов отрезать. Третий параметр может быть отрицательным - в этом случае отсчет начнется с конца (-1 - последний элемент, -2 - предпоследний и так далее). Третий параметр можно вообще не указывать - в этом случае массив отрежется до самого конца.
// Последний необязательный параметр регулирует сохранять ли ключи при отрезании, true - сохранять, false (по умолчанию) - не сохранять. Строковые ключи сохраняются, независимо от значения этого параметра.
// array_slice(массив, откуда отрезать, [сколько], [сохранять ключи = true]);

// Работа с array_splice
// Функция array_splice отрезает и возвращает часть массива. При этом отрезанная часть исчезает из массива. Вместо отрезанной части можно вставлять новые элементы.
// Первым параметром указывается массив для разрезания. Вторым параметром указывается, с какого элемента начинать отрезание, а третьим - сколько элементов отрезать. Третий параметр может быть отрицательным - в этом случае отсчет начнется с конца (-1 - последний элемент, -2 - предпоследний и так далее). Третий параметр можно вообще не указывать - в этом случае массив отрежется до самого конца.
// В последнем необязательном параметре можно задавать массив элементов, которые будут вставлены взамен удаленных.
// array_splice(массив, откуда отрезать, [сколько], [вставить взамен]);

// Работа с array_keys, array_values, array_combine
// Функция array_keys получает ключи массива и записывает их в новый массив array_keys(массив);
// Функция array_values выбирает все значения из массива array_values(массив);
// Функция array_combine осуществляет слияние двух массивов в один ассоциативный. Первым параметром функция принимает массив будущих ключей, а вторым - массив будущих значений array_combine(массив ключей, массив значений);

// Работа с array_flip, array_reverse
// Функция array_flip производит обмен местами ключей и значений массива array_flip(массив);
// Функция array_reverse переворачивает массив в обратном порядке. Первым параметром передается массив, а вторым - сохранять ключи при перестановке элементов или нет (true - да, false - нет). Второй параметр указывать необязательно. В таком случае по умолчанию вторым параметром является false. Строковые ключи всегда сохраняются, независимо от значения этого параметра array_reverse(массив, [сохранять ли ключи]);

// Работа с array_search
// Функция array_search осуществляет поиск значения в массиве и возвращает ключ первого найденного элемента. Если такой элемент не найдет - вернет false. Третий параметр задает строгое сравнение по типу (как по ===). Если поставить true - он будет сравнивать строго, а если false (по умолчанию) - то нет array_search(что ищем, где ищем, [сравнивать по типу = false]);

// Работа с array_replace
// Функция array_replace заменяет значения первого массива значениями с такими же ключами из других переданных массивов. Если ключ из первого массива присутствует во втором массиве, его значение заменяется на значение из второго массива. Если ключ есть во втором массиве, но отсутствует в первом - он будет создан в первом массиве. Если ключ присутствует только в первом массиве, то сохранится как есть.
// Если для замены передано несколько массивов, они будут обработаны в порядке передачи и более поздние массивы будут перезаписывать значения из предыдущих array_replace(массив, массив, массив...);

// Работа с сортировкой
// Для сортировки массивов в PHP существует несколько функций:
//  - sort - по возрастанию элементов,
//  - rsort - по убыванию элементов,
//  — asort - по возрастанию элементов с сохранением ключей,
//  — arsort - по убыванию элементов с сохранением ключей,
//  — ksort - по возрастанию ключей,
//  — krsort - по убыванию ключей,
//  - usort - по функции по элементам,
//  — uasort - по функции по элементам с сохранением ключей,
//  — uksort - по функции по ключам,
//  — natsort - натуральная сортировка.
// Все эти функции изменяют сам массив - это значит, что результат не нужно никуда присваивать: поменяется сам массив.

// Работа с array_rand
// Функция array_rand возвращает случайный ключ из массива. Первым параметром задается массив, а второй необязательный параметр указывает, сколько случайных ключей следует вернуть. Если он не указан - возвращается один ключ, а если указан - заданное количество ключей в виде массива array_rand(массив, [сколько ключей выбрать]);

// Работа с shuffle
// Функция shuffle осуществляет перемешивание массива так, чтобы его элементы шли в случайном порядке. При этом функция изменяет сам массив: это значит результат работы функции не нужно никуда присваивать - изменения произойдут над самим массивом shuffle(массив);

// Работа с array_unique
// Функция array_unique осуществляет удаление повторяющихся элементов (дублей) из массива array_unique(массив);

// Начало и конец массива
// Функция array_shift вырезает и возвращает первый элемент массива. При этом этот элемент исчезает из массива array_shift(массив);
// Функция array_pop вырезает и возвращает последний элемент массива. При этом этот элемент исчезает из массива array_pop(массив);
// Функция array_unshift добавляет элементы в начало массива. При этом переданный массив изменяется, а функция возвращает новое количество элементов в массиве. Элементы для добавления перечисляются через запятую array_unshift(массив, новые элементы); array_unshift($arr, 'a', 'b');
// Функция array_push добавляет элементы в конец массива. При этом переданный массив изменяется, а функция возвращает новое количество элементов в массиве. Элементы для добавления перечисляются через запятую array_push(массив, новые элемент); array_push($arr, 4, 5);

// Заполнение массива
// Функция array_pad дополняет массив определенным значением до заданного размера. Первым параметром функция принимает массив для заполнения, вторым параметром - до какого размера заполнить, третьим - чем заполнять. Второй параметр можно делать отрицательным - в этом случае массив будет дополнятся элементами не с конца, а с начала array_pad(массив, до какого размера заполнить, чем заполнять); array_pad($arr, 7, 0);
// Функция array_fill создает массив, заполненный элементами с определенным значением array_fill(ключ первого элемента, сколько элементов, чем заполнять);
// Функция array_fill_keys создает массив и заполняет массив элементами с определенным значением так, чтобы весь массив был с одинаковыми элементами, но разными ключами. Ключи берутся из массива, передаваемого первым параметром array_fill_keys(ключ первого элемента, сколько элементов, чем заполнять);

// Работа с array_chunk
// Функция array_chunk разбивает одномерный массив в двухмерный. Первым параметром она принимает массив, а вторым - количество элементов в каждом подмассиве array_chunk(массив, по сколько элементов);

// Работа с array_count_values
// Функция array_count_values производит подсчет количества всех значений массива. Возвращает ассоциативный массив, в котором ключами будут элементы массива, а значениями - их количество в массиве array_count_values(массив);

// Работа с array_map
// Функция array_map применяет заданную функцию ко всем элементам массива и возвращает измененный массив. Первым параметром функция принимает имя функции, а вторым - массив. Можно передавать дополнительные массивы третьим и так далее параметрами array_map(имя функции в кавычках, массив, [еще массивы через запятую]);

// Работа с array_intersect, array_diff
// Функция array_intersect вычисляет пересечение массивов - возвращает массив из элементов, которые есть во всех массивах, переданных в функцию array_intersect(массив, массив, массив...).
// Функция array_diff вычисляет разницу между массивами - возвращает массив, содержащий все элементы array, которых нет во всех массивах. Ключи в array массиве сохраняются array_diff(массив $array , массив ...$arrays ): массив.


// Работа с in_array
// Функция in_array проверяет наличие заданного элемента в массиве. Первым параметром она принимает что искать, а вторым - в каком массиве in_array(что искать, в каком массиве);
$arr = [1, 2, 3, 4, 5];
echo '<pre>';
print_r(in_array(3, $arr));
echo '</pre>';
echo "<br>";
echo "<br>";

// Работа с array_sum и array_product
// Функция array_sum вычисляет сумму элементов массива array_sum(массив);
// Функция array_product вычисляет произведение (умножение) элементов массива array_product(массив);
$arr = [1, 2, 3, 4, 5, 6];
echo array_sum($arr) . PHP_EOL;
echo "<br>";
echo array_product($arr) . PHP_EOL;
echo "<br>";
echo array_sum($arr) / count($arr) . PHP_EOL;
echo "<br>";
echo "<br>";

// Работа с range
// Функция range создает массив с диапазоном элементов. К примеру, можно создать массив, заполненный числами от 1 до 100 или буквами от 'a' до 'z'. Диапазон, который сгенерирует функция, задается параметрами: первый параметр откуда генерировать, а второй - докуда.
// Третий необязательный параметр функции задает шаг. К примеру, можно сделать ряд 1, 3, 5, 7, если задать шаг 2, или ряд 1, 4, 7, 10 если задать шаг 3 range(откуда, докуда, [шаг]);
echo '<pre>';
print_r(range(1, 100));
echo '</pre>';
echo "<br>";

echo '<pre>';
print_r(range('a', 'z'));
echo '</pre>';
echo "<br>";

echo '<pre>';
echo implode('-', range(1, 9));
echo '</pre>';
echo "<br>";

echo array_sum(range(1, 100));
echo "<br>";

echo array_product(range(1, 10));
echo "<br>";
echo "<br>";

// Работа с array_merge
// Функция array_merge сливает два и более массива вместе. Если в сливаемых массивах встречаются одинаковые ключи - останется только один из таких элементов. Если вам нужно, чтобы остались все элементы с одинаковыми ключами - используйте функцию array_merge_recursive array_merge(первый массив, второй массив...);
$arr1 = ['a', 'b', 'c', 'd', 'e'];
$arr2 = [1, 2, 3, 4, 5];

$result = array_merge($arr1, $arr2);
echo '<pre>';
print_r($result);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_slice
// Функция array_slice отрезает и возвращает часть массива. При этом сам массив не меняется. Первым параметром указывается массив для разрезания. Вторым параметром указывается, с какого элемента начинать отрезание, а третьим - сколько элементов отрезать. Третий параметр может быть отрицательным - в этом случае отсчет начнется с конца (-1 - последний элемент, -2 - предпоследний и так далее). Третий параметр можно вообще не указывать - в этом случае массив отрежется до самого конца.
// Последний необязательный параметр регулирует сохранять ли ключи при отрезании, true - сохранять, false (по умолчанию) - не сохранять. Строковые ключи сохраняются, независимо от значения этого параметра.
// array_slice(массив, откуда отрезать, [сколько], [сохранять ключи = true]);
$arr = [1, 2, 3, 4, 5];
$slice = array_slice($arr, 1, 3);
echo '<pre>';
print_r($slice);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_splice
// Функция array_splice отрезает и возвращает часть массива. При этом отрезанная часть исчезает из массива. Вместо отрезанной части можно вставлять новые элементы.
// Первым параметром указывается массив для разрезания. Вторым параметром указывается, с какого элемента начинать отрезание, а третьим - сколько элементов отрезать. Третий параметр может быть отрицательным - в этом случае отсчет начнется с конца (-1 - последний элемент, -2 - предпоследний и так далее). Третий параметр можно вообще не указывать - в этом случае массив отрежется до самого конца.
// В последнем необязательном параметре можно задавать массив элементов, которые будут вставлены взамен удаленных.
// array_splice(массив, откуда отрезать, [сколько], [вставить взамен]);

$result = array_splice($arr, 0, 3);
echo '<pre>';
print_r($result); // [1, 2, 3]
echo '</pre>';
echo "<br>";
echo '<pre>';
print_r($arr); // [4, 5]
echo '</pre>';
echo "<br>";
echo "<br>";

$arr = [1, 2, 3, 4, 5];
array_splice($arr, 1, 2);
echo '<pre>';
print_r($arr); // [1, 4, 5]
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

$arr = [1, 2, 3, 4, 5];
array_splice($arr, 0, 1);
array_splice($arr, 3, 1);
echo '<pre>';
print_r($arr); // [2, 3, 4]
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

$arr = [1, 2, 3, 4, 5];
$arrSlice = array_splice($arr, 3);
$arr[] = 'a';
$arr[] = 'b';
$arr[] = 'c';
$arrFinal = array_merge($arr, $arrSlice);
echo '<pre>';
print_r($arrFinal); // [1, 2, 3, 'a', 'b', 'c', 4, 5]
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_keys, array_values, array_combine
// Функция array_keys получает ключи массива и записывает их в новый массив array_keys(массив);
// Функция array_values выбирает все значения из массива array_values(массив);
// Функция array_combine осуществляет слияние двух массивов в один ассоциативный. Первым параметром функция принимает массив будущих ключей, а вторым - массив будущих значений array_combine(массив ключей, массив значений);

$keys = ['a', 'b', 'c', 'd', 'e'];
$elems = [1, 2, 3, 4, 5];
$result = array_combine($keys, $elems);
echo '<pre>';
print_r($result);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

$arr = ['a' => 1, 'b' => 2, 'c' => 3];
$keys = array_keys($arr);
$values = array_values($arr);
echo '<pre>';
print_r($keys);
echo '</pre>';
echo "<br>";
echo '<pre>';
print_r($values);
echo '</pre>';
echo "<br>";

$arr1 = ['a', 'b', 'c'];
$arr2 = [1, 2, 3];
$arrKeyValue = array_combine($arr1, $arr2);
echo '<pre>';
print_r($arrKeyValue);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_flip, array_reverse
// Функция array_flip производит обмен местами ключей и значений массива array_flip(массив);
// Функция array_reverse переворачивает массив в обратном порядке. Первым параметром передается массив, а вторым - сохранять ключи при перестановке элементов или нет (true - да, false - нет). Второй параметр указывать необязательно. В таком случае по умолчанию вторым параметром является false. Строковые ключи всегда сохраняются, независимо от значения этого параметра array_reverse(массив, [сохранять ли ключи]);
$arr1 = ['a' => 1, 'b' => 2, 'c' => 3];
$arr1 = array_flip($arr1);
echo '<pre>';
print_r($arr1);
echo '</pre>';
echo "<br>";

$arr = [1, 2, 3, 4, 5];
$arr = array_reverse($arr);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_search
// Функция array_search осуществляет поиск значения в массиве и возвращает ключ первого найденного элемента. Если такой элемент не найдет - вернет false. Третий параметр задает строгое сравнение по типу (как по ===). Если поставить true - он будет сравнивать строго, а если false (по умолчанию) - то нет array_search(что ищем, где ищем, [сравнивать по типу = false]);
$arr = ['-', 'a', 'b', '-', 'c', '-', 'd', 1];

echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
$result = array_search('1', $arr, true);
var_dump($result);
echo "<br>";
$result = array_search('-', $arr, true);
var_dump($result);
array_splice($arr, $result, 1);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";


// Работа с array_replace
// Функция array_replace заменяет значения первого массива значениями с такими же ключами из других переданных массивов. Если ключ из первого массива присутствует во втором массиве, его значение заменяется на значение из второго массива. Если ключ есть во втором массиве, но отсутствует в первом - он будет создан в первом массиве. Если ключ присутствует только в первом массиве, то сохранится как есть.
// Если для замены передано несколько массивов, они будут обработаны в порядке передачи и более поздние массивы будут перезаписывать значения из предыдущих array_replace(массив, массив, массив...);

$arr = ['a', 'b', 'c', 'd', 'e'];

$result = array_replace($arr, [0 => '!', 3 => '!!']);
echo '<pre>';
print_r($result);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с сортировкой
// Для сортировки массивов в PHP существует несколько функций:
//  - sort - по возрастанию элементов,
//  - rsort - по убыванию элементов,
//  — asort - по возрастанию элементов с сохранением ключей,
//  — arsort - по убыванию элементов с сохранением ключей,
//  — ksort - по возрастанию ключей,
//  — krsort - по убыванию ключей,
//  - usort - по функции по элементам,
//  — uasort - по функции по элементам с сохранением ключей,
//  — uksort - по функции по ключам,
//  — natsort - натуральная сортировка.
// Все эти функции изменяют сам массив - это значит, что результат не нужно никуда присваивать: поменяется сам массив.

$arr = ['3' => 'a', '1' => 'c', '2' => 'e', '4' => 'b'];
sort($arr);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
$arr = [3 => 'a', 1 => 'c', 2 => 'e', 4 => 'b'];
ksort($arr);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_rand
// Функция array_rand возвращает случайный ключ из массива. Первым параметром задается массив, а второй необязательный параметр указывает, сколько случайных ключей следует вернуть. Если он не указан - возвращается один ключ, а если указан - заданное количество ключей в виде массива array_rand(массив, [сколько ключей выбрать]);
$arr = ['a' => 1, 'b' => 2, 'c' => 3];
$key = array_rand($arr);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo $key . ' - ключ.';
echo "<br>";
echo $arr[$key] . ' - значение.';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с shuffle
// Функция shuffle осуществляет перемешивание массива так, чтобы его элементы шли в случайном порядке. При этом функция изменяет сам массив: это значит результат работы функции не нужно никуда присваивать - изменения произойдут над самим массивом shuffle(массив);
$arr = [1, 2, 3, 4, 5];
shuffle($arr);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
$arrNumber = range(1, 25);
$arrLetters = range('a', 'z');
shuffle($arrNumber);
shuffle($arrLetters);
echo "<br>";
echo '<pre>';
print_r($arrNumber);
echo '</pre>';
echo "<br>";
echo '<pre>';
print_r($arrLetters);
echo '</pre>';
echo "<br>";
echo "<br>";
$letters = range('a', 'z');
shuffle($letters);
$characters = implode($letters);
$newStr = str_shuffle($characters);

echo $newStr . '<br><br>';
echo substr($newStr, 0, 6);
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_unique
// Функция array_unique осуществляет удаление повторяющихся элементов (дублей) из массива array_unique(массив);

$arr = ['a', 'b', 'c', 'b', 'a'];

echo '<pre>';
print_r(array_unique($arr));
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Начало и конец массива
// Функция array_shift вырезает и возвращает первый элемент массива. При этом этот элемент исчезает из массива array_shift(массив);
// Функция array_pop вырезает и возвращает последний элемент массива. При этом этот элемент исчезает из массива array_pop(массив);
// Функция array_unshift добавляет элементы в начало массива. При этом переданный массив изменяется, а функция возвращает новое количество элементов в массиве. Элементы для добавления перечисляются через запятую array_unshift(массив, новые элементы); array_unshift($arr, 'a', 'b');
// Функция array_push добавляет элементы в конец массива. При этом переданный массив изменяется, а функция возвращает новое количество элементов в массиве. Элементы для добавления перечисляются через запятую array_push(массив, новые элемент); array_push($arr, 4, 5);

$arr = [1, 2, 3, 4, 5];
$first = array_shift($arr);
$last = array_pop($arr);
echo $first;
echo "<br>";
echo $last;
echo "<br>";
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";

$arr = [1, 2, 3, 4, 5];
array_unshift($arr, 0);
array_push($arr, 6, 7);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Заполнение массива
// Функция array_pad дополняет массив определенным значением до заданного размера. Первым параметром функция принимает массив для заполнения, вторым параметром - до какого размера заполнить, третьим - чем заполнять.
// Второй параметр можно делать отрицательным - в этом случае массив будет дополнятся элементами не с конца, а с начала array_pad(массив, до какого размера заполнить, чем заполнять); array_pad($arr, 7, 0);

// Функция array_fill создает массив, заполненный элементами с определенным значением array_fill(ключ первого элемента, сколько элементов, чем заполнять);

// Функция array_fill_keys создает массив и заполняет массив элементами с определенным значением так, чтобы весь массив был с одинаковыми элементами, но разными ключами. Ключи берутся из массива, передаваемого первым параметром array_fill_keys(ключ первого элемента, сколько элементов, чем заполнять);


$arr = ['a', 'b', 'c'];
$result = array_pad($arr, 6, '-');
echo '<pre>';
print_r($result);
echo '</pre>';
echo "<br>";
echo '<pre>';
print_r(array_fill(0, 10, 'x'));
echo '</pre>';
echo "<br>";
$arr = array_fill_keys(['a', 'b', 'c', 'd', 'e'], 'x');
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_chunk
// Функция array_chunk разбивает одномерный массив в двухмерный. Первым параметром она принимает массив, а вторым - количество элементов в каждом подмассиве array_chunk(массив, по сколько элементов);
$arr = range(1, 35);
$arr = array_chunk($arr, 5);
echo '<pre>';
print_r($arr);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_count_values
// Функция array_count_values производит подсчет количества всех значений массива. Возвращает ассоциативный массив, в котором ключами будут элементы массива, а значениями - их количество в массиве array_count_values(массив);

$arr = ['a', 'b', 'c', 'b', 'a'];
echo '<pre>';
print_r(array_count_values($arr));
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";

// Работа с array_map
// Функция array_map применяет заданную функцию ко всем элементам массива и возвращает измененный массив. Первым параметром функция принимает имя функции, а вторым - массив. Можно передавать дополнительные массивы третьим и так далее параметрами array_map(имя функции в кавычках, массив, [еще массивы через запятую]);

$arr = [1, 2, 3, 4, 5];

function degree($value): int {
    return $value ** 2;
}

$result = array_map('degree', $arr);
$result2 = array_map(static function ($var) {
    return $var ** 2;
}, $arr);
echo '<pre>';
print_r($result);
echo '</pre>';
echo "<br>";
echo "<br>";
echo '<pre>';
print_r($result2);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";


// Работа с array_intersect, array_diff
// Функция array_intersect вычисляет пересечение массивов - возвращает массив из элементов, которые есть во всех массивах, переданных в функцию array_intersect(массив, массив, массив...).
// Функция array_diff вычисляет разницу между массивами - возвращает массив, содержащий все элементы array, которых нет во всех массивах. Ключи в array массиве сохраняются array_diff(массив $array , массив ...$arrays ): массив.

$arr1 = [1, 2, 3, 4, 5];
$arr2 = [3, 4, 5, 6, 7];
$result = array_intersect($arr1, $arr2);
$result2 = array_diff($arr1, $arr2);
echo '<pre>';
print_r($result);
echo '</pre>';
echo "<br>";
echo "<br>";
echo '<pre>';
print_r($result2);
echo '</pre>';
echo "<br>";
echo "<br>";
echo "<br>";




