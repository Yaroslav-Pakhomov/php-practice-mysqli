<?php

declare(strict_types=1);

// включение вывод всех ошибок
error_reporting(E_ALL);
ini_set('display_errors', 'on');

// выключение вывод всех ошибок
// error_reporting(0);
// ini_set('display_errors', 'off');

// Кодировка
mb_internal_encoding('UTF-8');


// Работа с геттерами и сеттерами в ООП

// Метод конструктор с названием __construct. Суть в следующем - если в коде класса существует метод с таким названием - он будет вызываться в момент создания объекта.

class User {
    public string $name;
    private int $age; // объявим возраст приватным

    // Метод для чтения возраста юзера:
    public function getAge(): string {
        return $this->age . ' лет';
    }

    // возраст всегда будет меняться через метод setAge, так как в нем выполняется проверка возраста на корректность.
    public function setAge($age): void {
        // Проверим возраст на корректность
        if ($this->isAgeCorrect($age)) {
            $this->age = $age;
        }
    }

    private function isAgeCorrect($age): bool {
        return $age >= 18 && $age <= 60;
    }
}


$user = new User;

// Установим возраст
$user->setAge(50);

// Прочитаем новый возраст
echo $user->getAge(); // выведет 50

// Такой подход, который мы сейчас сделали, — стандартный. Его удобно использовать тогда, когда нам нужна какая-то проверка в сеттере. В терминах этого подхода метод getAge называется геттером (англ. getter), а метод setAge - сеттером (англ. setter).

// Очень часто бывает так, что даже если нам не нужны никакие проверки - все равно свойство объявляется приватным, а для доступа к нему используются геттеры и сеттеры. Почему? Потому что, возможно, нам захочется добавить проверку в дальнейшем и, если все изменения свойства в коде делаются через сеттер, нам не придется вносить правки в код снаружи класса - мы просто внесем одну правку в сеттере.
